# MyApp.py
# The Controller class ,the starting point of the program
# Editable UI version of the MVC application.
# Inherits from the Ui_MainWindow class defined in clientSide.py.
# Provides functionality to the 3 interactive widgets (2 push-buttons,
# and 1 line-edit).
# The class maintains a reference to the model that implements the logic
# of the app.The model is defined in class Model, in model.py.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, pyqtSlot
from clientSide import Ui_MainWindow #importing the ui class
import sys
from model import Model  #importing the model class

class MainWindowUIClass( Ui_MainWindow ):
   
    def __init__(self):
        '''Initialize super class'''
        super().__init__()
        self.model = Model() #creating the model class reference

    def setupUi( self,MW ):
        '''Setup the UI of the super class ,and add here code that relates to 
        the way we want our UI to operate'''
        super().setupUi(MW)
        #close the lower part of the splitter to hide the debug 
        # window when not in use.
        self.splitter.setSizes([300,0])

    #A method to print the debug info in the debug window
    def debugPrint(self, msg):
        '''print the message in the text box at the bottom of the splitter'''
        self.debugWindow.append(msg)

    # a method to clear all the text fields once an action is performed
    def updateAll(self):
        '''Updates the widgets whenever an interaction happens.
        Typically some interaction takes place, the UI responds and informs
        the model of the change. 
        Then this method is called, pulling from the model information that is 
        updated in the GUI
        '''
        #set the filepath textbox to the filename choosen or entered
        self.filePath.setText(self.model.getFileName())

    '''Defining slots declared in the clientSide UI file'''

    def returnPressedSlot(self):
        '''Called when the user presses Enter in the filepath Textbox'''
        #getting the File Name from the filePath 
        fileName = self.filePath.text()
        #if file Name isvalid then accepting it
        #else diplay a pop window
        if self.model.isValid(fileName):
            self.model.setFileName( self.filePath.text() )
            self.updateAll()
        else:
            m = QtWidgets.QMessageBox()
            m.setText("Invalid file name!\n" + fileName)
            m.setIcon(QtWidgets.QMessageBox.Warning)
            m.setStandardButtons(QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel)
            m.setDefaultButton(QtWidgets.QMessageBox.Cancel)
            ret = m.exec_()
            self.filePath.setText("")
            self.updateAll()
            self.debugPrint("Invalid file name provided " + fileName)
        self.debugPrint("RETURN key pressed in FilePath widget")

    def browseButtonSlot(self):
        '''Called when the user press the browse button'''
        #getting the file name from the file Explorer
        self.debugPrint("Browse button pressed")
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(None,"QFileDialog.getOpenFileName()","","All Files (*);;Python Files (*.py)",options = options)
        if fileName:
            self.debugPrint( "setting file name: "+ fileName)
            self.model.setFileName(fileName)
            self.updateAll()

def main():
    """
    This is the MAIN ENTRY POINT of our application.  The code at the end
    of the mainwindow.py script will not be executed, since this script is now
    our main program.   We have simply copied the code from clientSlide.py here
    since it was automatically generated by '''pyuic5'''.
    """
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = MainWindowUIClass()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

main()